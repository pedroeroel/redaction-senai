<script>
document.addEventListener("DOMContentLoaded", () => {
  const quizForms = document.querySelectorAll(".quiz-form");
  const finishBtn = document.getElementById("finish-btn");
  let correctAnswers = new Set();

  function updateFinishButton() {
    if (quizForms.length > 0 && correctAnswers.size === quizForms.length) {
      finishBtn.className =
        "px-10 py-4 bg-[#A78BFA] text-[#2A0F5E] text-lg font-bold rounded-full shadow-lg hover:bg-white hover:text-[#2A0F5E] transition-all duration-300 transform hover:scale-105";
      finishBtn.textContent = "Concluir Aula e Ganhar XP! ✨";
      finishBtn.disabled = false;
      finishBtn.style.cursor = "pointer";
      finishBtn.style.opacity = "1";
    } else {
      finishBtn.className =
        "px-10 py-4 bg-gray-500 text-[#2A0F5E] text-lg font-bold rounded-full shadow-lg opacity-50 cursor-not-allowed transition-all duration-300";
      finishBtn.textContent = "Complete todos os desafios para concluir ✨";
      finishBtn.disabled = true;
      finishBtn.style.cursor = "not-allowed";
      finishBtn.style.opacity = "0.5";
    }
  }

  // Helper: is numeric string (integer)
  function isIntegerString(s) {
    if (s === null || s === undefined) return false;
    const n = Number(s);
    return Number.isInteger(n);
  }

  // Helper: map letter (a,b,c...) to 0-based index. Returns -1 if not a letter.
  function letterToIndex(s) {
    if (!s) return -1;
    const m = s.toString().trim().toLowerCase().match(/^([a-z])/);
    if (!m) return -1;
    return m[1].charCodeAt(0) - 97;
  }

  // Helper: extract a single-letter key from option value (handles values like "a|text", "a - text", "a: text", or starting single letter)
  function extractLeadingKeyFromValue(s) {
    if (!s) return "";
    const v = s.toString().trim().toLowerCase();
    if (!v) return "";

    // If pipe-separated, take the first token
    if (v.includes("|")) {
      const first = v.split("|", 1)[0].trim();
      if (/^[a-z]$/.test(first)) return first;
    }

    // If starts with single letter followed by non-word char or end
    const m = v.match(/^\s*([a-z])(?=\W|$)/);
    if (m) return m[1];

    // Try other separators like ":" or "-"
    const toks = v.split(/[:\-]/);
    if (toks.length > 1) {
      const t = toks[0].trim();
      if (/^[a-z]$/.test(t)) return t;
    }

    // If value itself is a single letter
    if (/^[a-z]$/.test(v)) return v;

    return "";
  }

  quizForms.forEach((form, index) => {
    const feedback = form.querySelector(".quiz-feedback");
    const rawCorrect = (form.dataset.correct ?? "").toString().trim();
    const correctFeedback = form.dataset.correctFeedback || "Boa!";
    const wrongFeedback = form.dataset.wrongFeedback || "Tente novamente!";

    console.log(`Quiz #${index} - Correct Answer: "${rawCorrect}"`);

    form.addEventListener("submit", e => {
      e.preventDefault();

      const radios = Array.from(form.querySelectorAll('input[name="resposta"]'));
      const selected = radios.find(r => r.checked);

      if (!selected) {
        feedback.className = "quiz-feedback mt-4 p-3 rounded-lg bg-yellow-500";
        feedback.innerText = "Por favor, selecione uma opção!";
        return;
      }

      feedback.classList.remove("hidden");
      const selectedValue = selected.value.toString().trim().toLowerCase();
      const selectedValueKey = extractLeadingKeyFromValue(selected.value);

      let isCorrect = false;

      // 1) If data-correct looks like a letter (a, b, c, ...): interpret as option position (first, second, ...) OR match by key embedded in value
      const letterIndex = letterToIndex(rawCorrect);
      if (letterIndex >= 0) {
        const selectedIndex = radios.findIndex(r => r === selected); // 0-based index by displayed order
        if (selectedIndex === letterIndex || selectedValue === rawCorrect.toLowerCase() || selectedValueKey === rawCorrect.toLowerCase()) {
          isCorrect = true;
        }
      }
      // 2) If data-correct is numeric -> treat as 0-based index only
      else if (isIntegerString(rawCorrect)) {
        const correctIndex = parseInt(rawCorrect, 10);
        const selectedIndex = radios.findIndex(r => r === selected); // 0-based index
        if (!Number.isNaN(correctIndex) && selectedIndex === correctIndex) {
          isCorrect = true;
        }
      } else {
        // 3) Otherwise compare as string (e.g., full text) OR match by key embedded in value
        if (selectedValue === rawCorrect.toLowerCase() || selectedValueKey === rawCorrect.toLowerCase()) {
          isCorrect = true;
        } else {
          // If rawCorrect looks like an option label (e.g., 'Ler os textos...'), allow matching by label text
          const selectedLabel = selected.closest("label");
          if (selectedLabel) {
            const labelText = selectedLabel.innerText.replace(/\s+/g, " ").trim().toLowerCase();
            if (labelText.startsWith(rawCorrect.toLowerCase()) || labelText.includes(rawCorrect.toLowerCase())) {
              isCorrect = true;
            }
          }
        }
      }

      if (isCorrect) {
        feedback.className = "quiz-feedback mt-4 p-3 rounded-lg bg-green-500 text-[#E8E1CF]";
        feedback.innerHTML = "✅ " + correctFeedback;
        correctAnswers.add(index);
      } else {
        feedback.className = "quiz-feedback mt-4 p-3 rounded-lg bg-red-500 text-[#E8E1CF]";
        feedback.innerHTML = "❌ " + wrongFeedback;
        correctAnswers.delete(index);
      }

      updateFinishButton();
    });

    // Also update when user changes the radio selection (so state updates without re-submitting)
    form.querySelectorAll('input[name="resposta"]').forEach(radio => {
      radio.addEventListener("change", () => {
        const selected = form.querySelector('input[name="resposta"]:checked');
        if (!selected) return;
        form.dispatchEvent(new Event('submit', { cancelable: true, bubbles: true }));
      });
    });
  });

  // initialize
  updateFinishButton();
});
</script>
